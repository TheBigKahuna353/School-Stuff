#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>


int32_t addOdd(const int32_t data[], size_t n)
{
    int total;
    for (int i = 1; i < n; i += 2) {
        total += data[i];
        printf("%d\n", i);
    }
    return total;
}

size_t wordLength(char* string)
{
    int n = 0;
    while (string[n] != ' ') {
        n++;
    }
    return n;
}

uint16_t scanBase2(void)
{
    int c = getchar();
    int total = 0;
    while (c != -1) {
        if (c == '0' || c == '1') {
            total = total * 2 + (c - '0');
        } else {
            break;
        }
        c = getchar();
    }
    return total;
}

void min_swap(int16_t* lower, int16_t* high) {
    if (*lower > *high) {
        int16_t temp = *high;
        *high = *lower;
        *lower = temp;
    }
}

void swap3_bac(int16_t* x, int16_t* y, int16_t* z)
{
    min_swap(y, z);
    min_swap(x, z);
    min_swap(y, x);
}

size_t myIndex(uint32_t arr[], uint32_t* element)
{
    return element - arr;
}

typedef struct
{
    char name[30];
    float latitude;
    float longitude;
} City_t;

typedef struct {
    int64_t x;
    int64_t y;
    int64_t z;
} Vector3d_t;

Vector3d_t vector(int64_t x, int64_t y, int64_t z)
{
    Vector3d_t vec;
    vec.x = x;
    vec.y = y;
    vec.z = z;
    return vec;
}

Vector3d_t vectorMult(Vector3d_t a, int64_t s)
{
    return vector(a.x*s, a.y*s, a.z*s);
}

typedef struct {
    uint64_t id;
    uint8_t age;
    float gpa;
} Student_t;

Student_t newStudent(uint64_t id, uint8_t age, float gpa)
{
    Student_t stud;
    stud.id = id;
    stud.age = age;
    stud.gpa = gpa;
    return stud;
}

void printStudent(const Student_t* student)
{
    printf("%zu: Age %zu, GPA %0.2f\n", student->id, student->age, student->gpa);
}

void updateGpa(Student_t* student, float newGpa)
{
    student->gpa = newGpa;
}

void findInArray(int16_t* array, size_t n, int16_t value, int16_t** foundValueDest)
{
    *foundValueDest = NULL;
    for (int i=0; i < n; i++) {
        if (array[i] == value) {
            *foundValueDest = array + i;
        }
    }
}

uint16_t* newCopy(uint16_t* array, size_t numElements)
{
    uint16_t* newArray = malloc(numElements * 16);
    for (int i = 0; i < numElements; i++) {
        newArray[i] = array[i];
    }
    return newArray;
}

uint16_t func(uint8_t x)
{
    return x/2; //Only an example - could be anything. 
}

uint16_t callPassedFunc(uint16_t (*f)(uint8_t), uint16_t val)
{
    return f(val);
}

void* getNextField(void* packet, size_t fieldSize, size_t packetSize)
{
    static void* point = 0;
    if (point == 0) {
        point = packet;
    }
    void* ptr = (void*)malloc(fieldSize);
    ptr = point;
    point += fieldSize;
    if (point >= packet + packetSize) {
        point = 0;
    }
    return ptr;

}

int main(void)
{
//Messy - would usually be generated by a function. 
size_t packetSize = sizeof(uint8_t) + sizeof(uint16_t);
uint8_t packet[sizeof(uint8_t) + sizeof(uint16_t)] = {0};
packet[0] = 55;
*(uint16_t*)(packet+sizeof(uint8_t)) = 30000;

//Imaginary sending

//Read off values
uint8_t* firstValue = getNextField(packet, sizeof(uint8_t), packetSize);
uint16_t* secondValue = getNextField(packet, sizeof(uint16_t), packetSize); //Have read packetSize bytes, function should now be reset
printf("%u %u\n", *firstValue, *secondValue);
free(firstValue);
free(secondValue);

//Do it again to test reseting
firstValue = getNextField(packet, sizeof(uint8_t), packetSize);
secondValue = getNextField(packet, sizeof(uint16_t), packetSize);
printf("%u %u\n", *firstValue, *secondValue);
free(firstValue);
free(secondValue);
}

